<script src="https://d3js.org/d3.v4.min.js"></script>


<script type="text/javascript">

    const ELEM_SIZE = 30;
    const ELEM_DIST = 3 * ELEM_SIZE;
    const LINE_LEN = ELEM_DIST - 2 * ELEM_SIZE;
    const ELEM_ALPHA = 0.8;

    const X_OFFSET = 5;
    const Y_OFFSET = 5;

    const SVG_WIDTH = 500;
    const SVG_HEIGHT = 500;

    const ACTIVE_CLASS = "context-menu_active";
    const SELECTED_CIRCLE_CLASS = "selected_circle";

    const EDGE = "edge";

    const EMPTY_VERTEX = {
        xpos: null,
        ypos: null,
        gridx: null,
        gridy: null,
        vegetableIds: [],
        edges: {},
        affinity: 0
    };

    Object.defineProperty(Array.prototype, 'toggle', {
        enumerable: false,
        value: function (x) {
            var i = this.indexOf(x);
            if (i >= 0) {
                this.splice(i, 1);
                return this;
            }
            else {
                this.push(x);
                return this;
            }
        }
    });

    function getPairs(l1, l2) {
        var pairsl = [];
        for (var i1 = 0; i1 < l1.length; i1++) {
            for (var i2 = 0; i2 < l2.length; i2++) {
                if (l1[i1] != l2[i2])
                    pairsl.push([l1[i1], l2[i2]]);
            }
        }
        return pairsl;
    };

    function getPairsFromSet(l1) {
        var pairsl = [];
        for (var i1 = 0; i1 < l1.length; i1++) {
            for (var i2 = i1 + 1; i2 < l1.length; i2++) {
                pairsl.push([l1[i1], l1[i2]]);
            }
        }
        return pairsl;
    };

    // Fits the plant names into a square of size "dims"
    // Each plant must be in its own line (or spread over multiple if it is too long)    

    function fitPlants(d) {
        if(d.vegetableIds.length == 0) {
            return;
        }

        var splitPlantNames = d.vegetableIds.map((x) => vegetables[x].name.split(/\s+/));
        
        var getLongestWord = (x, y) => x.length > y.length ? x : y;
        var longestWord = splitPlantNames.map((x) => x.reduce(getLongestWord)).reduce(getLongestWord)
        var minrows = splitPlantNames.length;

        var scaleFactor = 1;

        var textElement = d3.select(this);
        var textElement = textElement.text("");

        var tmp = textElement.append("tspan").style("font-size", scaleFactor + "em").text(longestWord);
        while(tmp.node().getComputedTextLength() > 2*ELEM_SIZE) {
            scaleFactor = scaleFactor - 0.1;
            tmp.style("font-size", scaleFactor + "em");
        }
        tmp.remove();        

        while(!fillTextBox(textElement, splitPlantNames, scaleFactor)) {
            scaleFactor = scaleFactor - 0.1;
        }
    }

    /**
        Fills the textElement with splitPlantNames using fsize (in em) as style.
        Auxiliary method, returns true if the text fits and false otherwise.
    */
    function fillTextBox(textElement, splitPlantNames, fsize) {
        var lnum = 1;
        var sy = textElement.attr("y");
        var sx = textElement.attr("x");

        textElement.selectAll("tspan").remove();

        for(i in splitPlantNames) {
            var currentPlantName = splitPlantNames[i];
            var ctspan = textElement.append("tspan").attr("x", sx).attr("y", sy).attr("dy", lnum+"em").style("font-size", fsize + "em");
            var currentLine = "";
            for(j in currentPlantName) {
                var word = currentPlantName[j];                
                ctspan.text(currentLine + " " + word);
                if(ctspan.node().getComputedTextLength() <= 2*ELEM_SIZE) {
                    currentLine = currentLine + " " + word;
                }
                else {
                    ctspan.text(currentLine);
                    lnum = lnum + 1;
                    currentLine = word;
                    ctspan = textElement.append("tspan").attr("x", sx).attr("y", sy).attr("dy", lnum+"em").style("font-size", fsize + "em").text(currentLine);
                                    
                }                
            }
            lnum = lnum + 1;
        }

        var bb = textElement.node().getBBox();
        return bb.height <= 2 * ELEM_SIZE;
    }

    function initGarden(xdim, ydim) {

        function toIndex(ci, cj) {
            return ci * ydim + cj;
        }

        var g = {};
        g.vertices = [];
        g.edges = [];
        g.toIndex = toIndex;

        g.getVertex = function (x, y) {
            if (x >= xdim || y >= ydim) {
                return EMPTY_VERTEX;
            }
            return this.vertices[this.toIndex(x, y)];
        }

        g.getEdges = function (vertex) {
            return Object.values(vertex.edges).concat([
                this.getVertex(vertex.gridx, vertex.gridy + 1).edges.up,
                this.getVertex(vertex.gridx + 1, vertex.gridy).edges.left
            ]).filter((x) => x != null);
        }

        g.getAffinity = function (v1, v2) { // Po novem vegetable Ids...

            function getRelationshipsForPairs(plist) {
                var affinities = [];
                for (var i = 0; i < plist.length; i++) {
                    affinities.push(vegetables[plist[i][0]].relationships[plist[i][1]] || 0);
                }
                return affinities;
            }

            var pairs = getPairs(v1.vegetableIds, v2.vegetableIds);
            if (pairs.length > 1) {
                return getRelationshipsForPairs(pairs).reduce((x, y) => Math.min(x, y));
            }
            else return 0;
        }

        for (var i = 0; i < xdim; i++) {
            for (var j = 0; j < ydim; j++) {
                var cindex = toIndex(i, j);
                var tmp = {
                    xpos: ELEM_SIZE + i * ELEM_DIST,
                    ypos: ELEM_SIZE + j * ELEM_DIST,
                    gridx: i,
                    gridy: j,
                    vegetableIds: [],
                    edges: {},
                    affinity: 0
                };

                if (i > 0) {
                    var e = {
                        startVertexId: cindex,
                        endVertexId: toIndex(i - 1, j),
                        startx: tmp.xpos - ELEM_SIZE,
                        endx: tmp.xpos - ELEM_SIZE - LINE_LEN,
                        starty: tmp.ypos,
                        endy: tmp.ypos,
                        affinity: 0
                    };
                    tmp.edges['left'] = e;
                }

                if (j > 0) {
                    var e = {
                        startVertexId: cindex,
                        endVertexId: toIndex(i, j - 1),
                        startx: tmp.xpos,
                        endx: tmp.xpos,
                        starty: tmp.ypos - ELEM_SIZE,
                        endy: tmp.ypos - ELEM_SIZE - LINE_LEN,
                        affinity: 0
                    }
                    tmp.edges['up'] = e;
                }

                g.vertices.push(tmp);
            }
        }
        return g;
    }

    function viz() {
        var gardenGrid = d3.select("#gardenGrid");
        var mainElem = gardenGrid.selectAll("g").data(garden.vertices).enter();

        var elemEnter = mainElem.append("g");

        elemEnter.append("rect")
            .attr("x", (d) => X_OFFSET + d.xpos - ELEM_SIZE)
            .attr("y", (d) => Y_OFFSET + d.ypos - ELEM_SIZE)
            .attr("gridx", (d) => d.gridx)
            .attr("gridy", (d) => d.gridy)
            .attr("targetid", (d) => d.vegetableIds)
            .attr("width", ELEM_SIZE * 2)
            .attr("height", ELEM_SIZE * 2)
            .classed("unbound_circle", true)
            .style('stroke', function (d) {
                if (d.affinity == 0) return 'black';
                else if (d.affinity > 0) return 'green';
                else return 'red';
            })
            .style('stroke-width', function (d) {
                if (d.affinity == 0) return '1';
                else if (d.affinity > 0) return '3';
                else return '3';
            });

        elemEnter.append("text")
            .attr("x", (d) => X_OFFSET + d.xpos - ELEM_SIZE)
            .attr("y", (d) => Y_OFFSET + d.ypos - ELEM_SIZE)
            .attr("width", ELEM_SIZE * 2)
            .attr("height", ELEM_SIZE * 2)
            .classed("tName", true)
            .text((d) => d.vegetableIds.length == 0 ? "" : d.vegetableIds.map((x) => vegetables[x].name).join("\n"));

        elemEnter.selectAll("line")
            .data((d) => Object.values(d.edges))
            .enter().append("line")
            .attr('x1', (d) => d.startx + X_OFFSET)
            .attr('x2', (d) => d.endx + X_OFFSET)
            .attr('y1', (d) => d.starty + Y_OFFSET)
            .attr('y2', (d) => d.endy + Y_OFFSET)
            .attr('startVertexId', (d) => d.startVertexId)
            .attr('endVertexId', (d) => d.endVertexId);

        gardenGrid.selectAll("text").transition()
            .each(fitPlants);

        gardenGrid.selectAll("rect").transition()
            .style('stroke', function (d) {
                if (d.affinity == 0) return 'black';
                else if (d.affinity > 0) return 'green';
                else return 'red';
            })
            .style('stroke-width', function (d) {
                if (d.affinity == 0) return '1';
                else if (d.affinity > 0) return '3';
                else return '6';
            });

        gardenGrid.selectAll("line").transition()
            .style('stroke', function (d) {
                if (d.affinity == 0) return 'black';
                else if (d.affinity > 0) return 'green';
                else return 'red';
            })
            .style('stroke-width', function (d) {
                if (d.affinity == 0) return '2';
                else if (d.affinity > 0) return '6';
                else return '6';
            });
    }

    var vegetables = {{{ tojson vegetables }}};
    var garden = initGarden(4, 4);

    var additionMode = false;
    var inEditC = null;
    var inEditG = null;

    var selectedE = null;
    var selectedV = null;

    $(function () {
        var menu = $("#vegContextMenu");

        // clear selections
        $(".vfiltercb").prop("checked", false);

        function hideContextMenu() {
            if (additionMode) {
                additionMode = false;
                menu.removeClass(ACTIVE_CLASS);
                inEditC.removeClass(SELECTED_CIRCLE_CLASS);
                inEditC = null;
            }
        }

        function updateMenuSelections() {
                $(".context-menu_item_selected").removeClass("context-menu_item_selected");

                inEditG.vegetableIds.forEach(function(selectedVegetableId) {
                   $("#cmi" + selectedVegetableId).addClass('context-menu_item_selected');
            });
        }

        function updateEdgeDetails() {
            var sv = garden.vertices[parseInt(selectedE.attr('startVertexId'))];
            var ev = garden.vertices[parseInt(selectedE.attr('endVertexId'))];

            var pairs = getPairs(sv.vegetableIds, ev.vegetableIds);

            var t = "";

            for (var i = 0; i < pairs.length; i++) {
                var v1 = pairs[i][0];
                var v2 = pairs[i][1];
                var r1 = vegetables[v1];
                var r2 = vegetables[v2];
                var affinity = 0;

                if (r1.relationships[v2] > 0) {
                    affinity = 'pos';
                }
                else if (r1.relationships[v2] < 0) {
                    affinity = 'neg';
                }

                t = t + `<br /> <span class="${affinity}"> ${r2.name}  : ${r1.name} </span>`;
            }

            $("#connectionDetails").html(t);
        }

        function updateVertexDetails() {
            var v = garden.getVertex(parseInt(selectedV.attr('gridx')), parseInt(selectedV.attr('gridy')))
            var pairs = getPairsFromSet(v.vegetableIds);

            var t = "";

            for (var i = 0; i < pairs.length; i++) {
                var v1 = pairs[i][0];
                var v2 = pairs[i][1];
                var r1 = vegetables[v1];
                var r2 = vegetables[v2];
                var affinity = '';

                if (r1.relationships[v2] > 0) {
                    affinity = 'pos';
                }
                else if (r1.relationships[v2] < 0) {
                    affinity = 'neg';
                }

                t = t + `<br /> <span class="${affinity}"> ${r2.name}  : ${r1.name} </span>`;
            }

            $("#connectionDetails").html(t);
        }

        $("#gardenGrid").on('contextmenu', 'rect', function (e) {
            if (!additionMode) {
                additionMode = true;
                menu.addClass(ACTIVE_CLASS);
            } else {
                inEditC.removeClass(SELECTED_CIRCLE_CLASS);
            }

            inEditC = $(this);
            inEditC.addClass(SELECTED_CIRCLE_CLASS);
            inEditG = garden.getVertex(parseInt(inEditC.attr('gridx')), parseInt(inEditC.attr('gridy')));
            updateMenuSelections();

            menu.offset({ left: e.clientX, top: e.clientY });
            return false;
        });

        $("#gardenGrid").on('click', 'line', function (e) {
            selectedE = $(this);
            updateEdgeDetails();
        });

        $("#gardenGrid").on('click', 'rect', function (e) {
            selectedV = $(this);
            updateVertexDetails();
        });

        $("#gardenGrid").on('click', function (e) {
            hideContextMenu();
            return false;
        });

        $("#vegContextMenu").on('mouseenter', '.context-menu_item', function (e) {
            var edges = garden.getEdges(inEditG);
            var v = vegetables[$(this).attr('targetid')];
            var pAffinity = inEditG.affinity;
            var pVegetableIds = inEditG.vegetableIds.concat([]);
            inEditG.vegetableIds.toggle($(this).attr('targetid'));

            for (var i = 0; i < edges.length; i++) {
                var e = edges[i];
                e.affinity = garden.getAffinity(garden.vertices[e.startVertexId], garden.vertices[e.endVertexId]);
            }
            inEditG.affinity = garden.getAffinity(inEditG, inEditG);
            viz();

            // Restore previous state
            inEditG.vegetableIds = pVegetableIds;
            for (var i = 0; i < edges.length; i++) {
                var e = edges[i];
                e.affinity = garden.getAffinity(garden.vertices[e.startVertexId], garden.vertices[e.endVertexId]);
            }
            inEditG.affinity = pAffinity;
        });

        $("#vegContextMenu").on('mouseleave', '.context-menu_item', function (e) {
            viz();
        });

        $(".context-menu_item").on('click', function (e) {
            var tid = $(this).attr('targetid');
            inEditG.vegetableIds.toggle(tid);
            var edges = garden.getEdges(inEditG);
            for (var i = 0; i < edges.length; i++) {
                var e = edges[i];
                e.affinity = garden.getAffinity(garden.vertices[e.startVertexId], garden.vertices[e.endVertexId]);
            }
            inEditG.affinity = garden.getAffinity(inEditG, inEditG);
            viz();
            hideContextMenu();
        });

        $(".vfiltercb").on('change', function (e) {
            var targetEl = "#cmi" + this.value;
            $(targetEl).toggleClass("hidden");
        });

        $("#updateDims").on('click', function (e) {
            var xdim = parseInt($("#xinput").val());
            var ydim = parseInt($("#yinput").val());
            var garden2 = initGarden(xdim, ydim);
            garden = garden2;
            $("#gardenGrid").empty();
            viz();
        });

        viz();

    });
</script>

<nav class="context-menu blur" id="vegContextMenu">
    <ul class="context-menu_items">
        {{#each vegetables}}
        <li class="context-menu_item hidden" targetid="{{@key}}" id="cmi{{@key}}">{{name}}</li>
        {{/each}}
    </ul>
</nav>


<div class="row h-100">
    <div class="col-md-3" id="subset_selector">
        <div>
            <ul class="vegfilter">
                {{#each vegetables}}
                <li>
                    <input type="checkbox" class="vfiltercb" value="{{@key}}" id="vf{{@key}}" />
                    <label for="vf{{@key}}">{{name}}</label>
                </li>
                {{/each}}
            </ul>
        </div>
    </div>

    <div class="col-md-6 h-100">
        <div>
            <span>Velikost:
                <input type="text" id="xinput" value="4" /> x
                <input type="text" id="yinput" value="4" /> polj.
                <input type="button" value="OK" id="updateDims" />
        </div>
        <div>&nbsp</div>
        <svg id="gardenGrid" width="100%" height="100%" />
    </div>

    <div>
        Podrobnosti:        
        <div class="details" id="connectionDetails">
        </div>
    </div>
</div>